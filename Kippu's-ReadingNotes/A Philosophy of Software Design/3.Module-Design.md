# 模块设计  

## 毫无疑问，模块化设计是软件设计中必要的思维

即使长期处于战术性编程的环境下，也一定采用模块化设计来优化软件网页增加可读性

**模块化设计下开发者每次都只需要面对整体复杂性的一小部分（即使很多时候大量的依赖性问题会在模块化环境下产生许多问题）**

模块间不得不相互了解，即所谓的依赖关系

> 一个方法的参数会在该方法和所有调用该方法的代码之间产生依赖关系。如果所需的参数发生变化，则必须修改该方法的所有调用，以符合新的方法签名。
> 

---

## 接口与实现

所谓的模块化设计下，产生了模块本身的两大特性

**一个好的模块，它的接口必然比它的实现部分更简单，并且最好在修改实现方式时不影响接口，即不影响其他的模块**

- 接口
- 实现

### 一、接口： 接口定义分为一个正式部分和一个非正式部分

**正式部分——签名，以及所有公有的方法等变量、名称、类型（可通过编程语言直接检查出正确性）**

**非正式部分——编程语言不能简单理解，比如函数删除某参数命名文件（往往通过注释描述）**

而往往非正式部分的占比远远大于正式部分

接口往往是模块的**抽象**，他让模块中的实现对于其他模块而言不再重要，而设计一个抽象接口，在于明确**重要的是什么**

> 例如，考虑一个文件系统。文件系统提供的抽象省略了许多细节，例如用于选择存储设备上的哪些块用于存储给定文件中的数据的机制。这些详细信息对于文件系统的用户而言并不重要（只要系统提供足够的性能即可）。但是，文件系统实现的一些细节对用户很重要。大多数文件系统将数据缓存在主内存中，并且它们可能会延迟将新数据写入存储设备以提高性能。一些应用程序（例如数据库）需要确切地知道何时将数据写入存储设备，以便它们可以确保在系统崩溃后数据仍将保留。因此，将数据刷新到辅助存储的规则必须在文件系统的接口中可见
> 

一个好的“抽象”，其被抽象的部分一定是真正的“无关紧要”。

### 二、实现：在模块化设计中，实现指的是具体的代码和逻辑

它遵循接口定义并提供功能支持

以文件系统为例，我们可以定义一个文件操作接口，并在具体实现中提供不同的存储方式，比如本地存储、云存储或数据库存储

---

## 深模块与浅模块

### 深模块：

> 最好的模块是那些提供强大功能但具有简单接口的模块。我用“深”一词来描述这样的模块。
> 

**深模块应该是通过很简单的接口，为其他使用该接口的组件（类）提供强大的“深不见底”的功能**

而**Linux**为大部分功能提供的接口，其表现就是一个典型的深模块——程序员在调用诸如“如何强制执行权限，以使一个用户无法修改或删除另一用户的文件？”等功能时，是不知道背后成千上万行等代码的，也无需了解。

### 浅模块：

> 浅层模块是其接口与其提供的功能相比相对复杂的模块。例如，实现链表的类很浅。操作链表不需要太多代码（插入或删除元素仅需几行），因此链表抽象不会隐藏很多细节。链表接口的复杂度几乎与其实现的复杂度一样高
> 

**浅类不一定能避免，但在复杂性优化上确实没有太大帮助**

浅类几乎不存在任何抽象性的事情，几乎调用此模块的程序员都不得不在接口部分观察到**大多数其功能实现的方法**

又或者虽然不必在接口上观察到太多对功能实现方法，**但其蕴含了太多知识**，对熟悉度不高的程序员而言提供了不必要的学习难度

---

## Classitis：

此处中文书翻译为了“类炎”，此处用英文记忆做更好的警告

> 编程中的传统观点是，类应该**小**而不是深。经常告诉学生，类设计中最重要的事情是将较大的类分成较小的类。
> 

**但事实上过多的类不但增加了系统的复杂性，还会导致许多的重复引用，不利于“深模块”的形成。**

### 类并非越多越好

---

## 警示信号：“浅模块”

**这是本章主要强调的编程中要避免的事物。相对模块提供的功能，接口过于复杂，这就是浅模块，不利于降低设计的复杂性**

本书还介绍了许多的警示信号，在编程中带入这些警示来询问自己以及自己的代码就能避免太多不必要的复杂性（尽管作者自己说“不一定”）

### 将实现的复杂性隐藏使其“不重要”、“难以察觉”，多编写“深类”。这样一来能有效的降低代码的复杂性。