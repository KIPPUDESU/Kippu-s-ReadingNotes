**本章为前篇提到的“深模块”提供了创建的方法论**

---

## 信息隐藏：每个模块内都封装有设计决策的知识，但在调用时（使用其接口）却无需了解这些知识。

被隐藏的信息往往包含许多的方法实现细节，说到底，作为开发者在使用一个模块时，不用总考虑自己需要学些什么，把引用转化为简单的体力劳动再好不过。

**简而言之，被隐藏的信息几乎与外部完全没有依赖关系，但又含有大量的价值**

## 信息泄露：一个设计决策被多个模块了解，不得不做出反映

不得不做出反映，意味着每一个新增的反映都多出了一份依赖关系。

### 即使通过创建一个新的类把所有受影响的信息进行封装，但一个新的类对应的接口暴露了太多不必要的知识，提供的价值遍大大降低

**简而言之，功能实现的某个知识在接口上体现，信息泄漏就已经发生**

---

## 导致信息泄露的原因，在本章被分为以下几大原因

- **接口暴露了实现中的知识与细节——接口暴露知识**
- **私有属性通过无限制的公有方法暴露信息——私有属性公有暴露**
- **按照操作时间顺序拆分模块——时序分解**
- **过多的类导致多个类共同维护一个内部状态——类过多**

### 一、接口暴露知识：

### 接口（如类的 public 方法）应该只暴露“必要的操作”，而非内部结构或状态。但开发者常因“方便”而在接口中暴露了底层逻辑或状态细节

当我们在接口中暴露了类的内部结构、处理流程或数据组织方式时，外部模块就会依赖这些细节，从而产生耦合，增加复杂性

### 二、私有属性公有暴露：

### 声明私有属性一定程度上确实有利于信息隐藏，但需要保证通过此方法无法通过其他公有方法（取值设值）暴露出来

> **来自ChatGPT**
> 
> 
> 假设你有一个房间（类），你把某个物品（属性）锁在抽屉里（声明为私有），本意是不让别人随便拿。但你又在门口贴了一个说明：“想要抽屉里的东西可以按这个按钮”——这就像你写了 `getX()` 方法。
> 
> 那别人虽然不能直接开抽屉（访问私有属性），但通过按钮（getter）还是可以拿到里面的内容——这就违背了你最初的“隐藏”。
> 

### 三、时序分解

### 在开发过程中因为过于关注操作顺序，而忽略或放弃了使用工作职能划分模块

> **典型分解**
> 
> 
> openFile()
> readHeader()
> readData()
> closeFile()
> 

因为采用了按时间顺序划分的方法，所以依旧让调用者不得不了解了其中功能的具体实现

### 四、类过多

### 多个可以互相配合的功能却被划分成了多个浅类，让调用者不得不通过观察大量的类来解析他们之间互相配合（自主拼装细节造成耦合）的方法，造成信息泄露

> 一个组使用两种不同的类来接收 HTTP 请求。第一类将来自网络连接的请求读取为字符串，第二类将字符串解析。这是时间分解的一个示例（“首先读取请求，然后解析它”）
> 

过多的类之间共享了的信息造成了负担，因此最好合并为一个类。

### 最好把信息隐藏在类中，通过减少某个公用变量使用位置的数量，并设计不需要被外部了解的私有方法

### 被隐藏的信息只有在外部不需要时才有被隐藏的意义，不能一概而论

---

## 警示信号：“过度暴露”

**一个API中不必要的知识增加了调用者的负担**

## 警示信号：”信息泄露“

**一个知识被运用在功能实现还有接口等多个地方**

## 警示信号：“时序分解”

**按照功能发生的顺序来设计模块而不是按照功能划分**