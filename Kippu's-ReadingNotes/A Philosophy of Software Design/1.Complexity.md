# 复杂性

## 在软件（网页）设计时，复杂性带来诸多问题

> 复杂性是指与软件系统结构有关的，使人难以理解和修改系统的所有因素
> 

---

## 为设计带来复杂性的两大原因

- `依赖关系（dependency）`
- `模糊性（obscurity）`

### Dependency：几乎无法避免，但好的软件设计就应该追求减少过多的依赖

组件通信或者对接双方等情况中往往产生依赖，依赖关系除了被减少避免以外，也可以尽量使得依赖关系足够明显。更轻松的观察或搜索到依赖所需注意的部分（变量）

### Obscurity：让代码中重要信息变得尽量明显

变量名称，变量的单位（是否明显提示），都会增加代码的模糊性

**文档**与**信息表**都能很大程度上方便其他使用该组件开发的人员

---

## 复杂性的表现：

- 更变放大
- 认知负担
- 不知道未知

### **更变放大**：一个简单的修改更变带来了许多其他位置的代码修改（提升了维护难度，以及后期其他的功能实现）

> 为了改变这样一个网站的背景，开发者可能不得不手动修改每一个现有页面；这对于一个拥有数千个页面的大型网站来说几乎是不可能的。
> 

避免所谓的更变放大的**解决**就是要

**让一个代码决策尽量影响更少的代码**

推荐的方式是代码封装

### **认知负担**：面对某个组件的时候，或者使用了某一段功能实现的代码时，不得不了解这段代码里面的相关知识，一旦信息遗漏的越多，带来的风险越高

> 假设C语言中的一个函数分配内存，返回指向能内存的指针，并假定调用者将释放内存。这增加了使用该函数的开发者的认知负担；如果开发者未能释放内存，就会出现内存泄露。
> 

全局变量、方法过多的API、不一致、模块依赖，都会成为认知负担

**需要更多的代码不一定更复杂，反之，极少的代码有可能带来认知负担**

### 不知道未知：使用某个组件想实现某个功能时，却并不知道要做什么才能达到效果，**明明必须知道，却不知道从哪知道**

> 网站使用一个集中变量来决定横幅广告的背景颜色，因此似乎很容易更改。但是，有几个网页使用了较深的背景色来突出重点，而这种较深的颜色是在各个网页中明确指定的。如果背景色发生变化，那么强调色也必须随之变化。
> 

解决方法除了让代码中**必须知道的知识**更加明显以外

或许还可以通过**文档**为开发者提供便利，降低“不知道”

---

## 复杂性增量

需要在起步阶段就注意到代码设计中呈现出的各种危险信号，其中带来的

**依赖关系**以及**模糊性**都应该格外注意，防止小问题在代码后续发展中成为扩张的大问题

---

## 总而言之，需要采取“零容忍”的强迫态度面对依赖关系和模糊性，让后续维护者可以节省更多时间更安全的更改代码。